---
title: Tagging EF Core sql queries
tags: [EF Core, Query Tags]
---


[.NET Core 2.2](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-2/#query-tags) introduce a small feature known as **Query Tags**. It allows you to annotate queries generated by EF Core. This is super useful for debugging purposes, after all one of the main complains you often hear about EntityFramework is the over completed SQL statements it generates.

I am currently working on a project called [Chinook](https://github.com/circleupx/Chinook), it demonstrates how to build a JSON:API on .NET Core. The project uses EF Core to query a SQLite database. Here is an example of one of the LINQ queries used to get a collection of users.

```c#
public async Task<IEnumerable<Customer>> Handle(GetCustomerResourceCollectionCommand request, CancellationToken cancellationToken)
{
    return await _chinookDbContext.Customers.ToListAsync(cancellationToken);
}
```

Here is the SQL query generated by EF Core.

```sql
SELECT "c"."CustomerId", "c"."Address", "c"."City", "c"."Company", "c"."Country", "c"."Email", "c"."Fax", "c"."FirstName", "c"."LastName", "c"."Phone", "c"."PostalCode", "c"."State", "c"."SupportRepId"
FROM "customers" AS "c"
```

We can tag the original LINQ query with a message using the [TagWith](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.tagwith?view=efcore-5.0) method.

```c#
public async Task<IEnumerable<Customer>> Handle(GetCustomerResourceCollectionCommand request, CancellationToken cancellationToken)
{
    var tagMessage = $"Calling from {nameof(GetCustomerResourceCollectionHandler)}";
    return await _chinookDbContext.Customers.TagWith(tagMessage).ToListAsync(cancellationToken);
}
```

and here is the SQL query generated by this LINQ query, as you can see it included our tag message. 

```sql
-- Calling from GetCustomerResourceCollectionHandler
SELECT "c"."CustomerId", "c"."Address", "c"."City", "c"."Company", "c"."Country", "c"."Email", "c"."Fax", "c"."FirstName", "c"."LastName", "c"."Phone", "c"."PostalCode", "c"."State", "c"."SupportRepId"
FROM "customers" AS "c"
```

We can improve this code by recording the exact line number that generated the query. That can be accomplished by creating an extension method of IQueryable, like this.

```c#
public static class IQueryableTaggingExtensions
{
    public static IQueryable<T> TagWithSource<T>(this IQueryable<T> queryable,
        [CallerLineNumber] int lineNumber = 0,
        [CallerFilePath] string filePath = "",
        [CallerMemberName] string memberName = "")
    {
        return queryable.TagWith($"{memberName}  - {filePath}:{lineNumber}");
    }

    public static IQueryable<T> TagWithSource<T>(this IQueryable<T> queryable,
        string tag,
        [CallerLineNumber] int lineNumber = 0,
        [CallerFilePath] string filePath = "",
        [CallerMemberName] string memberName = "")
    {
        return queryable.TagWith($"{tag}{Environment.NewLine}{memberName}  - {filePath}:{lineNumber}");
    }
}
```

I copied this IQueryableTaggingExtensions class from [**Phil Scott**](https://thirty25.com/). The original code exist in [this](https://github.com/thirty25/ef-core-tagging/blob/master/src/EfCoreTagging.Data/IQueryableTaggingExtensions.cs) Github repo, he also wrote up a [post](https://thirty25.com/posts/tagging-query-with-ef-core/) on Query Tags. 

I'm going to update our LINQ query to use this new extension class.

```c#
public async Task<IEnumerable<Customer>> Handle(GetCustomerResourceCollectionCommand request, CancellationToken cancellationToken)
{
    var tagMessage = $"Calling from {nameof(GetCustomerResourceCollectionHandler)}";
    return await _chinookDbContext.Customers.TagWithSource(tagMessage).ToListAsync(cancellationToken);
}
```

Now the generated SQL statement looks like this.

```sql
-- Calling from GetCustomerResourceCollectionHandler
-- Handle  - C:\Users\Yunier\source\repos\Chinook\src\Chinook.Infrastructure\Handlers\GetCustomerResourceCollectionHandler.cs:27
SELECT "c"."CustomerId", "c"."Address", "c"."City", "c"."Company", "c"."Country", "c"."Email", "c"."Fax", "c"."FirstName", "c"."LastName", "c"."Phone", "c"."PostalCode", "c"."State", "c"."SupportRepId"
FROM "customers" AS "c"
```

As you can see our original message, the name of method and line number were included as a tag on the generated SQL statement.

**Credits:** [Better Tagging of EF Core Queries](https://thirty25.com/posts/tagging-query-with-ef-core/)