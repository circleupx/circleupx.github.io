<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on Yunier&#39;s Blog</title>
    <link>https://www.yunier.dev/tags/docker/</link>
    <description>Recent content in Docker on Yunier&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 23 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://www.yunier.dev/tags/docker/rss" rel="self" type="application/rss+xml" />
    <item>
      <title>Power Up Integration Tests with Test Containers</title>
      <link>https://www.yunier.dev/post/2023/power-up-integration-tests-with-tests-containers/</link>
      <pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.yunier.dev/post/2023/power-up-integration-tests-with-tests-containers/</guid>
      <description>Introduction In my blog post Integration Testing Using WebApplicationFactory I spoke about the benefits of testing a .NET Core Web API using WebApplicationFactory. The idea is that WebApplicationFactory creates a local HTTP server in-memory, meaning that when using WebApplicationFactory you are not mocking the HTTP request made to your API, you are actually using the API as if it were hosted in a live environment.
The benefit here is that your test code seats in the middle of the Web API and the client code calling the API, meaning you can now test how the API behaves under certain requests from the client.</description>
    </item>
    
  </channel>
</rss>
