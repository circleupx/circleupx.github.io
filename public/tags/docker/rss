<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on Yunier&#39;s Wiki</title>
    <link>http://localhost:1313/tags/docker/</link>
    <description>Recent content in Docker on Yunier&#39;s Wiki</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 23 Apr 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/docker/rss" rel="self" type="application/rss+xml" />
    <item>
      <title>Power Up Integration Tests With Test Containers</title>
      <link>http://localhost:1313/post/2023/power-up-integration-tests-with-tests-containers/</link>
      <pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/2023/power-up-integration-tests-with-tests-containers/</guid>
      <description>&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;&#xA;&lt;p&gt;In my blog post &lt;a href=&#34;http://localhost:1313/post/2021/integration-testing-using-webapplicationfactory/&#34;&gt;Integration Testing Using WebApplicationFactory&lt;/a&gt; I spoke about the benefits of testing a .NET Core Web API using &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.testing.webapplicationfactory-1?view=aspnetcore-7.0&#34;&gt;WebApplicationFactory&lt;/a&gt;. The idea is that WebApplicationFactory creates a local HTTP server in-memory, meaning that when using WebApplicationFactory you are not mocking the HTTP request made to your API, you are actually using the API as if it were hosted in a live environment.&lt;/p&gt;&#xA;&lt;p&gt;The benefit here is that your test code seats in the middle of the Web API and the client code calling the API, meaning you can now test how the API behaves under certain requests from the client. One drawback of using WebApplicationFactory would be having to mock API dependencies, for example, the database. A common option for .NET developers using a relational database like SQL Server is to use SQLite in the integration tests, however, even that solution suffers from other drawbacks, our friend Jimmy Bogard goes into more detail in his blog &lt;a href=&#34;https://jimmybogard.com/avoid-in-memory-databases-for-tests/&#34;&gt;Avoid In-Memory Databases for Tests&lt;/a&gt;. What if instead of faking the database we actually used a real live database in our integration tests? There is a way, how? Well, with Docker.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
