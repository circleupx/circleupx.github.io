<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OpenAPI on Yunier&#39;s Blog</title>
    <link>https://www.yunier.dev/tags/openapi/</link>
    <description>Recent content in OpenAPI on Yunier&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 18 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://www.yunier.dev/tags/openapi/rss" rel="self" type="application/rss+xml" />
    <item>
      <title>Use a custom OpenAPI specification file in .NET</title>
      <link>https://www.yunier.dev/post/2023/use-a-custom-openapi-specification-file-in-.net/</link>
      <pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.yunier.dev/post/2023/use-a-custom-openapi-specification-file-in-.net/</guid>
      <description>.NET has the ability to auto-generated OpenAPI specifications based on your code. You can use different decorators on your code like ProducesResponseTypeAttribute or ConsumesAttribute to produce more descriptive response details for web API help pages generated by tools like Swagger.
What if you didn&amp;rsquo;t want to use the autogenerated spec, what if you instead wanted to expose an already written spec, perhaps because you follow an API-first approach to building an API instead of a Code-First approach.</description>
    </item>
    
  </channel>
</rss>
