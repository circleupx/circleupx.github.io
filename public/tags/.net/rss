<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>.NET on Yunier&#39;s Blog</title>
    <link>https://www.yunier.dev/tags/.net/</link>
    <description>Recent content in .NET on Yunier&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 18 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://www.yunier.dev/tags/.net/rss" rel="self" type="application/rss+xml" />
    <item>
      <title>Use a custom OpenAPI specification file in .NET</title>
      <link>https://www.yunier.dev/post/2023/use-a-custom-openapi-specification-file-in-.net/</link>
      <pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.yunier.dev/post/2023/use-a-custom-openapi-specification-file-in-.net/</guid>
      <description>.NET has the ability to auto-generated OpenAPI specifications based on your code. You can use different decorators on your code like ProducesResponseTypeAttribute or ConsumesAttribute to produce more descriptive response details for web API help pages generated by tools like Swagger.
What if you didn&amp;rsquo;t want to use the autogenerated spec, what if you instead wanted to expose an already written spec, perhaps because you follow an API-first approach to building an API instead of a Code-First approach.</description>
    </item>
    
    <item>
      <title>Using AutoFixture</title>
      <link>https://www.yunier.dev/post/2023/using-autofixture/</link>
      <pubDate>Mon, 02 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.yunier.dev/post/2023/using-autofixture/</guid>
      <description>I enjoy writing unit tests and any tools that make writing tests easier are appreciated. For the last year, I have incorporated AutoFixture into all of my unit tests. I have found AutoFixture to be an excellent tool, it changed the way I approach the &amp;ldquo;Arrange&amp;rdquo; phase.
Previously, my arrange phase involved manually assigning values to properties, in a small class that is referenced by a few tests, you may tolerate manually assigning values.</description>
    </item>
    
    <item>
      <title>Code Coverage In .NET</title>
      <link>https://www.yunier.dev/post/2022/code-coverage/</link>
      <pubDate>Tue, 15 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.yunier.dev/post/2022/code-coverage/</guid>
      <description>If you are writing unit tests in .NET, you may eventually find the need to generate code coverage reports to show how much coverage your project has. The best tool for code coverage reports in my experience has been coverlet because it supports both .NET Framework and .NET Core.
NUnit NUnit, the tried and tested framework originally being a port of JUnit. A powerful tool that when combined with coverlet console can be used to generate code coverage reports.</description>
    </item>
    
    <item>
      <title>Authorization Code From Terminal</title>
      <link>https://www.yunier.dev/post/2022/authorization-code-from-terminal/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.yunier.dev/post/2022/authorization-code-from-terminal/</guid>
      <description>I was recently presented with a unique challenge at work. I needed to create a script that clones repositories from Bitbucket. The problem is that as of June 2022, Bitbucket only supports managing repositories using OAuth via two grant types, the authorization code grant &amp;amp; the implicit grant.
I won&amp;rsquo;t get into the details here but the implicit grant is no longer recommended and is in fact discouraged from ever being used.</description>
    </item>
    
    <item>
      <title>Shortening URLs</title>
      <link>https://www.yunier.dev/post/2022/shortening-urls/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.yunier.dev/post/2022/shortening-urls/</guid>
      <description>I was recently talking to another developer about the importance of never exposing internal identifiers to the outside world. A well-known example of this is using an auto-incrementing identity field in SQL and exposing that field through an API. A client can look at the highest number to tell how many records exist, in an ordering system this is far from ideal. Now everyone will know how many orders you have created.</description>
    </item>
    
    <item>
      <title>Extracting Values From Types</title>
      <link>https://www.yunier.dev/post/2022/extracting-values-from-types/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.yunier.dev/post/2022/extracting-values-from-types/</guid>
      <description>Learned a cool little trick a while back from Khalid. As a developer, you will often run into scenarios that require you to get a subset of all fields from a model. There are many ways to achieve this task, returning the type and then grabbing each property, for example, take the following User type.
public class User { public User(string name, DateTime dob) { var random = new Random(); Id = random.</description>
    </item>
    
    <item>
      <title>Preventing Invalid Assembly Dependencies</title>
      <link>https://www.yunier.dev/post/2022/preventing-invalid-assembly-dependencies/</link>
      <pubDate>Sat, 12 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.yunier.dev/post/2022/preventing-invalid-assembly-dependencies/</guid>
      <description>.NET makes it super simple to update the dependencies of a project. If you are following a solution structure like Clean Architecture where the Web project should not be referenced by the Core project or you have created your own solution structure that requires certain projects do not reference another project then you might need a way to avoid having developers incorrectly adding dependencies.
The diagram above gives a high-level view of all project dependencies in a Clean Architecture solution.</description>
    </item>
    
    <item>
      <title>The Order Of Interfaces Impacts Performace</title>
      <link>https://www.yunier.dev/post/2021/the-order-of-interfaces-impacts-performance/</link>
      <pubDate>Sat, 28 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.yunier.dev/post/2021/the-order-of-interfaces-impacts-performance/</guid>
      <description>I was looking through some of my bookmarked Github issues when I rediscovered issue #32488, in that issue a comment was made that caught my attention. The comment stated that in .NET the order of interfaces impacts performance. This is because in the .NET CLR all class definitions have a collection of methods and interface definitions. Casting is a linear search that walks the interface definition. If you are constantly casting to an Interface located at the end then the CLR must do a longer walk.</description>
    </item>
    
    <item>
      <title>The Problem With AcquireRequestState</title>
      <link>https://www.yunier.dev/post/2020/the-problem-with-acquirerequeststate/</link>
      <pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.yunier.dev/post/2020/the-problem-with-acquirerequeststate/</guid>
      <description>In my second post, I wanted to cover AcquireRequestState. In my four years as a developer I have encountered issues with AcquireRequestState twice. So, what in the world is AcquireRequestState.
AcquireRequestState is part of the ASP.NET Life Cycle, this is an event raised by the HttpApplication, it keeps session state in sync. Though I suspect that most developers are familiar with this event for being a major performance pain in their .</description>
    </item>
    
    <item>
      <title>Configure Serilog Sub-Loggers Using XML App Settings</title>
      <link>https://www.yunier.dev/post/2020/configure-serilog-sub-logger-from-appsettings/</link>
      <pubDate>Mon, 31 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.yunier.dev/post/2020/configure-serilog-sub-logger-from-appsettings/</guid>
      <description>Serilog has a neat feature that allows you to configure sub-loggers. With this feature you can essentially have log specific instances running on your application.
I recently had to configure a .NET Framework application to use two different sub-loggers and while I was able find many examples online on how to configure sub-loggers through AppSettings.json, I did not find any examples on how to configure them through AppSettings.config/App.config so I wanted to document that process on this post.</description>
    </item>
    
  </channel>
</rss>
