---
title: The Platform
tags: [web components, UseThePlatform, HTML, CSS]
author: "Yunier"
date: "2021-08-18"
description: "Guide on the current state of the UI world."
---

HTML, CSS, and Javascript, are the languages of the world wide web, the [platform](https://youtu.be/BzX4aTRPzno?t=937). They are used to create websites, to make them interactive, and to make them beautiful. At one point in my career, I was more plugged into this world. A world that I feel I've fallen behind since I myself have not exclusively worked on a UI project since the days of AngularJS. That doesn't mean that I don't do any front-end work anymore, it is just that these days I spent most of the time doing back-end development. I am familiar with some of the modern frameworks like [Angular](https://angular.io/), [React.js](https://reactjs.org/), [Next.js](https://nextjs.org/) and [everyone's new favorite](https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-web-frameworks), [svelte](https://svelte.dev/). By falling behind I mean that I am not up to date with some of the new tools and technologies that have been created since the days of AngularJS. I want to use this post to write about some of these new techniques and tools that are available for front-end development.

I would like to start by exploring micro frontends, a term originally coined by the team over at [ThoughtWorks](https://www.thoughtworks.com/) on their [2016 technology radar](https://www.thoughtworks.com/radar/techniques/micro-frontends). With their most [recent technology radar](https://www.thoughtworks.com/radar/techniques/micro-frontends) advising the tech industry to adopt micro frontends. So, just what in the world are micro frontends and how is this pattern for building front-end applications different from [island architechture](https://jasonformat.com/islands-architecture/)? Given that both micro frontend and island architecture advocate creating independent UI components. The key difference is their approach to building the front-end, the idea behind the island architecture is that the HTML is rendered on the server, the HTML rendered would contain placeholders that denote regions (think widgets) on the HTML that can be hydrated on the client. Essentially you have an HTML page is rendered with most of the functionality readily available for use, loading independent apps on the client.

Both micro frontend and island architecture try to bring the [benefits](https://stackify.com/6-key-benefits-of-microservices-architecture/) of microservices to the front-end, benefits like being technology agnostic and having code isolation. Thought you should really avoid mixing multiple frameworks on the same application, a problem that is known as [micro frontend anarchy](https://www.thoughtworks.com/radar/techniques/micro-frontend-anarchy), though technically possible, it should be avoided. In a micro frontend architecture, you should only standardize on styling and how the different parts of the application are integrated. For styling the go-to techniques are [CSS-in-JS](https://medium.com/dailyjs/what-is-actually-css-in-js-f2f529a2757), a technique [popularized](https://speakerdeck.com/vjeux/react-css-in-js) by [Christopher Chedeau](http://blog.vjeux.com/), and[CSS Modules](https://github.com/css-modules/css-modules). 

{: .notice--info}
Do not confuse [CSS Modules](https://github.com/css-modules/css-modules), the community standard with [CSS Modules](https://github.com/whatwg/html/pull/4898/), the standard created by the Web Hypertext Application Technology Working Group (WHATWG) even though they both share the same name. Remember, developers are bad are naming things.

One of the main problems these techniques are attempting to solve is the fact that CSS was never bound to any scope, hence the name Cascading Style Sheets. CSS was created in a world where we expected the full HTML to be returned from the server. These techniques aim to avoid namespace collision, performance degradation that comes from using CSS at scale, and reducing the size of CSS bundles. You should know that these patterns come at a cost, you should be aware of their [benefits](https://medium.com/object-partners/css-in-js-benefits-drawback-and-tooling-80286b03f9aa) and [tradeoff](https://www.freecodecamp.org/news/the-tradeoffs-of-css-in-js-bee5cf926fdb/) before you use them.

Then there are [web components](https://www.webcomponents.org/), which consist of a number of APIs that allow you to build independent applications. This is done using [Custom Elements](https://www.webcomponents.org/specs#the-custom-elements-specification), an API that allows you to define behaviors and styles for new HTML elements. The [shadow DOM](https://www.webcomponents.org/specs#the-shadow-dom-specification), which lets you scope CSS.  [HTML template](https://www.webcomponents.org/specs#the-html-template-specification), defines how to declare fragments of markup that go unused at page load, but can be instantiated later on at runtime, and [ES Modules](https://www.webcomponents.org/specs#the-es-module-specification), defines the inclusion and reuse of JS documents in other JS documents. Web components are a great way to build independent applications, applications that are rendered on the client because up until 2020, the only way to use Shadow DOM was to construct a shadow root using JavaScript. For example.

```javascript
const host = document.getElementById('host');
const shadowRoot = host.attachShadow({mode: 'open'});
shadowRoot.innerHTML = '<h1>Hello Shadow DOM</h1>';
```
 
If you are working on an app the does [server side rendering](https://developers.google.com/web/updates/2019/02/rendering-on-the-web) (SSR), then you will need to use the [declaritive shadow dom](https://web.dev/declarative-shadow-dom/), otherwise, you will run into performance and rendering issues, [FOUC](https://en.wikipedia.org/wiki/Flash_of_unstyled_content) which stands for 'show a flash of unstyled content' being the most common. Declarative Shadow Rom brings the shadow dom to the server. However, it does bring another set of issues as noted by Rich Harris, the creator of [svelte.js](https://svelte.dev/). Declarative shadow dom is only supported in Chrome as of August 2021.

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">1. create a component standard<br>2. oops, it doesn&#39;t work without JS<br>3. create declarative shadow DOM<br>4. oops, embedding CSS in JS is bad<br>5. create CSS modules<br>6. oops, CSS modules don&#39;t work with declarative shadow DOM<br>7. create declarative constructible stylesheets<br>8. oops, ... <a href="https://t.co/Vm3jqxcB5U">https://t.co/Vm3jqxcB5U</a></p>&mdash; Rich Harris (@Rich_Harris) <a href="https://twitter.com/Rich_Harris/status/1422596305973567495?ref_src=twsrc%5Etfw">August 3, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

{: .notice--info}
You should check out [vanilla-extract](https://github.com/seek-oss/vanilla-extract). It allows you to write your styles in TypeScript (or JavaScript) with locally scoped class names and CSS Variables, then generate static CSS files at build time.

As noted in the tweet, CSS modules do not work with a declarative shadow dom, meaning we can't use CSS modules on server rendering applications. The google chrome team proposed [declaritive constructible stylesheets](https://wicg.github.io/construct-stylesheets/), it aims to fix this problem by relying on APIs that avoid FOUC. I'm starting to feel like a lot of these issues could have been avoided if the [scope specification](https://www.w3.org/TR/css-scoping-1/) had become a part of CSS. Luckily for us [some](https://twitter.com/TerribleMia/) out, there are still [fighting the good fight](https://css.oddbird.net/scope/explainer/), hoping to simplify how we use CSS because to me all these patterns stem from the fact that we seem to have a hard time scoping CSS.

Anyways, moving away from web components to another front-end pattern that I've been seen pop up lately, and that is rendering HTML completely on the server. In reality, this is not a new pattern. This is how most of the web worked up until ~2011. One key player in this area is [Hotwire](https://hotwired.dev/), created by the same guys that made [Ruby on Rails](https://rubyonrails.org/). Hotwire is heavily used over at [Hey.com](https://www.hey.com/). It works great, for the most part, but I am concern with the fact that many of the people that created the project left the project after the [basecamp debacle](https://www.platformer.news/p/-what-really-happened-at-basecamp).

[Blazor](https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor) is another popular choice for building SPA with C# by running on the server or browser utilizing [WebAssembly](https://webassembly.org/). I honestly don't know how I feel about Blazor and its role in the platform. I do like the idea of being able to use [LINQ](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/) on the browser, that is simply because LINQ is an awesome feature of the C# language.

Can't forget about [Progressive Web Apps](https://docs.microsoft.com/en-us/microsoft-edge/progressive-web-apps-chromium/), PWA leverage the power of the platform to create installable applications that do not require a store of any kind to act as a middle man between the consumers and the applications, kinda like the Play Store or Apple Store. Progressive web apps offer many amazing benefits, but I often hear that they can be complicated, which may explain why I've only seen one or two companies successfully used them. The top companies [being Twitter](https://blog.twitter.com/engineering/en_us/topics/open-source/2017/how-we-built-twitter-lite) and Google.


That be all for now. Till next time, cheerio.